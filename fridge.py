# -*- coding: utf-8 -*-
"""fridge.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JVT6J_EruTLhTF7_06WJ7-9CfeX7slQ7
"""

# ==============================================================================
# Fridge Predictive Maintenance: Simulation ➜ Dataset ➜ LSTM Model
# ==============================================================================

import json, uuid, random
from datetime import datetime, timedelta
import pandas as pd, numpy as np
from tqdm import tqdm
import joblib

# --- Fridge Simulator ---------------------------------------------------------
class FridgeSimulator:
    def __init__(self):
        self.device_id = f"fridge-{uuid.uuid4()}"
        self.current_time = datetime.utcnow() - timedelta(days=random.randint(30, 90))
        self.time_step = timedelta(hours=random.randint(1, 4))
        self.state = self.get_healthy_state()

    def get_healthy_state(self):
        return {
            "internal_temp_c": round(random.uniform(2.0, 5.0), 1),
            "door_open_flag": 0,
            "power_consumption_w": round(random.uniform(100, 200), 1),
            "compressor_rpm": random.randint(800, 1200)
        }

    def simulate_failure_step(self):
        self.state["internal_temp_c"] = min(self.state["internal_temp_c"] + round(random.uniform(5.0, 10.0), 1), 20.0)
        self.state["power_consumption_w"] += round(random.uniform(50, 100), 1)
        self.state["compressor_rpm"] = max(self.state["compressor_rpm"] - random.randint(200, 500), 0)
        if random.random() < 0.3:
            self.state["door_open_flag"] = 1

    def generate_record(self, is_failing=False):
        rec = {
            "recordId": str(uuid.uuid4()),
            "deviceId": self.device_id,
            "deviceType": "fridge",
            "timestamp": self.current_time.isoformat() + "Z",
            "metrics": self.state.copy(),
            "label": {
                "failure_imminent": is_failing,
                "failure_type": "compressor_failure" if is_failing else "none"
            }
        }
        self.current_time += self.time_step
        return rec

    def run_simulation(self, healthy_records=50, failing_records=10):
        data = []
        for _ in range(healthy_records):
            self.state = self.get_healthy_state()
            data.append(self.generate_record(False))
        for _ in range(failing_records):
            self.simulate_failure_step()
            data.append(self.generate_record(True))
        return data

# --- Generate Dataset ---------------------------------------------------------
records = []
for _ in tqdm(range(300), desc="Simulating fridges"):
    sim = FridgeSimulator()
    records.extend(sim.run_simulation(
        healthy_records=random.randint(30, 50),
        failing_records=random.randint(10, 15)
    ))
random.shuffle(records)

with open("fridge_dataset.json", "w") as f:
    json.dump(records, f)
print(f"✅ Fridge dataset: {len(records)} records")

# --- Data Prep / LSTM identical to Laptop version -----------------------------
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
import tensorflow as tf

df = pd.read_json("fridge_dataset.json")
metrics = pd.json_normalize(df["metrics"])
labels  = pd.json_normalize(df["label"])
df = pd.concat([df.drop(["metrics","label","recordId"],axis=1), metrics, labels], axis=1)
df["timestamp"] = pd.to_datetime(df["timestamp"])
df.sort_values(["deviceId","timestamp"], inplace=True)
df["failure_imminent"] = df["failure_imminent"].astype(int)

feature_cols = df.drop(columns=["deviceId","deviceType","timestamp","failure_type","failure_imminent"]).columns
scaler = StandardScaler()
df[feature_cols] = scaler.fit_transform(df[feature_cols])
joblib.dump(scaler, "fridge_scaler.joblib")

train_ids, test_ids = train_test_split(df["deviceId"].unique(), test_size=0.25, random_state=42)
train_df = df[df.deviceId.isin(train_ids)]
test_df  = df[df.deviceId.isin(test_ids)]

SEQ_LEN = 10
def create_sequences(d, feats, target):
    X,y = [],[]
    for _, g in d.groupby("deviceId"):
        f = g[feats].values
        t = g[target].values
        for i in range(len(g)-SEQ_LEN):
            X.append(f[i:i+SEQ_LEN])
            y.append(t[i+SEQ_LEN])
    return np.array(X), np.array(y)

X_train, y_train = create_sequences(train_df, feature_cols, "failure_imminent")
X_test,  y_test  = create_sequences(test_df,  feature_cols, "failure_imminent")

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Input, LSTM, Dense, Dropout
from tensorflow.keras.callbacks import EarlyStopping
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import matplotlib.pyplot as plt, seaborn as sns

model = Sequential([
    Input(shape=(SEQ_LEN, len(feature_cols))),
    LSTM(64),
    Dropout(0.3),
    Dense(32, activation="relu"),
    Dropout(0.3),
    Dense(1, activation="sigmoid")
])
model.compile(optimizer="adam", loss="binary_crossentropy", metrics=["accuracy"])
model.fit(X_train, y_train, epochs=50, batch_size=64, validation_split=0.2,
          callbacks=[EarlyStopping(monitor="val_loss", patience=5, restore_best_weights=True)], verbose=1)

model.save("fridge_lstm_model.keras")
joblib.dump(list(feature_cols), "fridge_feature_columns.joblib")

y_pred = (model.predict(X_test) > 0.5).astype(int)
print("Accuracy:", accuracy_score(y_test, y_pred))
print(classification_report(y_test, y_pred))
cm = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues")
plt.show()